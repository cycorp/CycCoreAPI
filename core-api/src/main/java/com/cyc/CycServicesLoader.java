package com.cyc;

/*
 * #%L
 * File: CycServicesLoader.java
 * Project: Core API
 * %%
 * Copyright (C) 2015 - 2019 Cycorp, Inc
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.ServiceLoader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static java.util.stream.Collectors.toList;

/**
 * This class is solely responsible for loading Cyc API services, such as
 * {@link com.cyc.kb.spi.KbApiService}.
 * 
 * <p>Note that the relevant service provider file in META-INF/services should be generated by the 
 * serviceloader-maven-plugin, specified in the provider project's pom.xml file.
 * 
 * @author nwinant
 */
public class CycServicesLoader {
  
  //====|    Fields    |==========================================================================//
  
  private static final Logger LOG = LoggerFactory.getLogger(CycServicesLoader.class);
  
  private final Map<Class<? extends CycApiEntryPoint>, CycApiEntryPoint> entryPointServices
          = new HashMap<>();
  
  //====|    Construction    |====================================================================//
  
  protected CycServicesLoader() {
  }
  
  //====|    Protected    |=======================================================================//
  
  protected synchronized <T extends CycApiEntryPoint> T getApiEntryPoint(
          Class<T> clazz, boolean allowMissingServices) {
    if (!entryPointServices.containsKey(clazz)) {
      entryPointServices.put(clazz, loadApiEntryPoint(clazz, allowMissingServices));
    }
    return (T) entryPointServices.get(clazz);
  }
  
  protected synchronized <T extends CycApiEntryPoint> T getApiEntryPoint(
          Class<T> clazz, Class<? extends T> defaultImplementation) {
    if (!entryPointServices.containsKey(clazz)) {
      entryPointServices.put(clazz, loadApiEntryPoint(clazz, defaultImplementation));
    }
    return (T) entryPointServices.get(clazz);
  }
  
  private <T extends CycApiEntryPoint> T loadApiEntryPoint(Class<T> clazz, 
                                                           boolean allowMissingServices) {
    final List<T> providers = loadServiceProviders(clazz, allowMissingServices);
    return selectServiceProvider(providers, clazz);
  }
  
  private <T extends CycApiEntryPoint> T loadApiEntryPoint(Class<T> clazz, 
                                                           Class<? extends T> defaultImplementation) {
    final List<T> providers = loadServiceProviders(clazz, true);
    final T result = selectServiceProvider(providers, clazz, defaultImplementation);
    if (result != null) {
      return result;
    }
    throw new RuntimeException(
            "No providers found for " + clazz.getCanonicalName()
                    + " and could not find default implementation " + defaultImplementation);
  }
  
  protected <T> List<T> loadServiceProviders(Class<T> clazz, boolean allowMissingServices) {
    final String clazzName = clazz.getCanonicalName();
    LOG.debug("Attempting to find {} service providers...", clazzName);
    final List<T> results = new ArrayList();
    final ServiceLoader<T> svcLoader = ServiceLoader.load(clazz);
    final Iterator<T> iter =  svcLoader.iterator();
    while (iter.hasNext()) {
      results.add(iter.next());
    }
    if (results.isEmpty()) {
      final String errMsg = "No providers found for " + clazzName;
      if (allowMissingServices) {
        LOG.warn(errMsg);
      } else {
        throw new RuntimeException(errMsg);
      }
    } else if (results.size() > 1) {
      LOG.warn("Loaded {} {} providers: {}", results.size(), clazzName, results);
    } else {
      LOG.debug("Loaded one {} provider: {}", clazzName, results.get(0));
    }
    return results;
  }
  
  protected <T> T selectServiceProvider(List<T> providers, Class<T> clazz) {
    if ((providers == null) || providers.isEmpty()) {
      return null;
    }
    if (providers.size() > 1) {
      throw new RuntimeException("Expected exactly one provider for " + clazz.getCanonicalName() 
              + " but found " + providers.size() + ": " + providers);
    }
    return providers.get(0);
  }
  
  protected <T> T selectServiceProvider(List<T> allProviders, 
                                        Class<T> clazz, 
                                        Class<? extends T> defaultImplementation) {
    if (allProviders != null) {
      {
        final List<T> providers = allProviders.stream()
                .filter(p -> !p.getClass().equals(defaultImplementation))
                .collect(toList());
        final T result = selectServiceProvider(providers, clazz);
        if (result != null) {
          return result;
        }
      }
      final T defaultResult = allProviders.stream()
              .filter(p -> p.getClass().equals(defaultImplementation))
              .findFirst()
              .orElse(null);
      if (defaultResult != null) {
        return defaultResult;
      }
    }
    try {
      return defaultImplementation.newInstance();
    } catch (InstantiationException | IllegalAccessException ex) {
      throw new RuntimeException("Could not instantiate provider " + defaultImplementation, ex);
    }
  }
  
}
